<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>webpack & TS</title>
    <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
  </head>
  <style>
    #painter {
      width: 1000px;
      height: 500px;
      background-color: antiquewhite;
      position: relative;
      margin: auto;
    }
  </style>
  <body>
    <button id="react">çŸ©å½¢</button>

    <div id="painter">
      <canvas id="canvasId" width="1000px" height="500px"></canvas>
    </div>
  </body>
  <script src="./dist/bundle.js" type="module"></script>
  <script>
    const defaultPointCorrd = {
      x1: [20, 20],
      y1: [20, 200],
      y2: [200, 200],
      x2: [200, 20],
    }
    let pressCorrd = null // å½“å‰æŒ‰ä¸‹åœ†çš„åæ ‡
    let drawType = null // å½“å‰è¦å¼€å§‹ç»˜åˆ¶çš„ç±»å‹
    let haveGraph = false // é¡µé¢ä¸­æ˜¯å¦å­˜åœ¨å›¾å½¢

    window.onload = function () {
      let defaultCtx
      let outCtx
      let outCanvas
        // åˆ›å»ºç¦»å±canvasè‡ªæ‰§è¡Œå‡½æ•°
      ;(function () {
        outCanvas = document.createElement('canvas')
        outCanvas.width = 1000
        outCanvas.height = 500
        outCtx = outCanvas.getContext('2d')
      })()
      // è·å–é¡µé¢canvas
      const canvas = document.getElementById('canvasId')
      defaultCtx = canvas.getContext('2d')
      draw(defaultCtx, outCtx, canvas)
    }

    const react = document.getElementById('react')
    react.onclick = function () {
      drawType = 'react'
    }

    function draw(defaultCtx, outCtx, canvas) {
      mouseDown(defaultCtx, canvas)
      mouseup(canvas)
      mouseMove(defaultCtx, outCtx, canvas)
      mouseOut(canvas)
    }
    function initCanvas(ctx) {
      console.log('ğŸ¤¡ ~~ ctx', ctx)
      pointDrawCircle(defaultPointCorrd, ctx)
      drawLine(defaultPointCorrd, ctx)
      haveGraph = true
    }
    // ç”»åœ†
    // è¿™é‡Œå¦‚æœå‘ç°ç”»çš„åœ†çš„ä½ç½®å’Œå®é™…çš„ä¸å¯¹åº”ï¼Œå¯èƒ½æ˜¯canvasçš„å®½é«˜éœ€è¦å¿…é¡»æŒ‰ç…§è¡Œå†…æ ·å¼è®¾ç½®
    function drawCircle(x, y, ctx, radius = 5) {
      ctx.beginPath()
      ctx.strokeStyle = '#000'
      ctx.arc(x, y, radius, 0, Math.PI * 2)
      ctx.fillStyle = '#000'
      ctx.fill()
      ctx.stroke()
    }
    // æ ¹æ® x1: [20, 20], è¿™ç§åæ ‡æ ¼å¼ç”»åœ†
    function pointDrawCircle(pointCorrd, ctx) {
      Object.entries(pointCorrd).forEach(([key, value]) => {
        const [x, y] = value
        drawCircle(x, y, ctx)
      })
    }

    // é¼ æ ‡æŒ‰ä¸‹
    function mouseDown(ctx, ele) {
      ele.onmousedown = function (e) {
        if (!drawType) return

        switch (drawType) {
          case 'react':
            if (!haveGraph) {
              initCanvas(ctx)
            }

            break

          default:
            break
        }

        const { offsetX, offsetY } = e || {}
        for (const [key, value] of Object.entries(defaultPointCorrd)) {
          // if (value == [offsetX, offsetY]) {
          //   pressCorrd = key
          // }
          if (
            value[0] < offsetX + 5 &&
            value[0] > offsetX - 5 &&
            value[1] < offsetY + 5 &&
            value[1] > offsetY - 5
          ) {
            pressCorrd = key
          }
        }
      }
    }
    //ç”»çº¿
    function drawLine(pointCorrd, ctx) {
      const { x1, y1, y2, x2 } = pointCorrd ?? {}
      ctx.beginPath()
      ctx.moveTo(x1[0], x1[1])
      ctx.lineTo(y1[0], y1[1])
      ctx.lineTo(y2[0], y2[1])
      ctx.lineTo(x2[0], x2[1])
      ctx.lineWidth = 2
      ctx.strokeStyle = '#28B1D9'
      ctx.closePath()
      ctx.fillStyle = 'rgba(40, 177, 217, 0.2)'
      ctx.fill()
      ctx.stroke()
    }

    // é¼ æ ‡æŠ¬èµ·
    function mouseup(ele) {
      ele.onmouseup = function (e) {
        const { offsetX, offsetY } = e || {}
        // é¼ æ ‡æŠ¬èµ·åè®¾ç½®å½“å‰æŒ‰ä¸‹çš„åæ ‡ä¸ºnull
        pressCorrd = null
      }
    }

    // é¼ æ ‡ç§»åŠ¨
    function mouseMove(defaultCtx, outCtx, ele) {
      ele.onmousemove = function (e) {
        if (pressCorrd) {
          const { offsetX, offsetY } = e || {}
          defaultPointCorrd[pressCorrd] = [offsetX, offsetY]
          outDraw(outCtx, defaultCtx)
        }
      }
    }

    var startTime
    var endTime
    //ç¦»å±canvasä¸Šç»˜åˆ¶ä¹‹ådrawImageåˆ°domCanvasä¸­
    function outDraw(outCtx, defaultCtx) {
      outCtx.clearRect(0, 0, outCtx.canvas.width, outCtx.canvas.height)
      startTime = performance.now()

      pointDrawCircle(defaultPointCorrd, outCtx)
      drawLine(defaultPointCorrd, outCtx)
      defaultCtx.clearRect(
        0,
        0,
        defaultCtx.canvas.width,
        defaultCtx.canvas.height
      )
      defaultCtx.drawImage(outCtx.canvas, 0, 0)

      // è®°å½•æ¸²æŸ“ç»“æŸæ—¶é—´
      endTime = performance.now()
      // è®¡ç®—æ¸²æŸ“æ‰€èŠ±è´¹çš„æ—¶é—´
      var elapsedTime = endTime - startTime

      console.log('æ¸²æŸ“æ‰€èŠ±è´¹çš„æ—¶é—´ï¼š' + elapsedTime + 'æ¯«ç§’')
    }

    // é¼ æ ‡ç¦»å¼€å…ƒç´ 
    function mouseOut(ele) {
      ele.onmouseout = function (e) {
        pressCorrd = null
      }
    }

    // æ¸…ç©ºç”»å¸ƒ
    function clearCanvas() {
      ctx.clearRect(0, 0, 1000, 500)
    }
  </script>
</html>
